import MetaTrader5 as mt5
import time
from datetime import datetime
import pandas as pd
import numpy as np

# === CONFIG ===
SYMBOL = "BTCUSDm"
TIMEFRAME = mt5.TIMEFRAME_M15
LOT_SIZE = 0.20
TP_DOLLARS = 100
SL_DOLLARS = 30
WMA_PERIOD = 5
CHECK_INTERVAL = 5  # seconds

# === INITIALIZE MT5 ===
if not mt5.initialize():
    print("MT5 initialization failed")
    quit()

# === FUNCTION: Get Historical Candles + WMA ===
def get_candles():
    rates = mt5.copy_rates_from_pos(SYMBOL, TIMEFRAME, 0, WMA_PERIOD + 2)
    df = pd.DataFrame(rates)
    df['time'] = pd.to_datetime(df['time'], unit='s')
    weights = np.arange(1, WMA_PERIOD + 1)
    df['wma'] = df['close'].rolling(WMA_PERIOD).apply(
        lambda x: np.dot(x, weights) / weights.sum(), raw=True)
    return df

# === FUNCTION: Get Latest Tick Prices ===
def get_prices():
    tick = mt5.symbol_info_tick(SYMBOL)
    ask = tick.ask
    bid = tick.bid
    price = (ask + bid) / 2
    return ask, bid, price

# === FUNCTION: Place Buy/Sell Order ===
def place_order(direction):
    ask, bid, _ = get_prices()
    entry_price = ask if direction == mt5.ORDER_TYPE_BUY else bid
    tp = entry_price + TP_DOLLARS if direction == mt5.ORDER_TYPE_BUY else entry_price - TP_DOLLARS
    sl = entry_price - SL_DOLLARS if direction == mt5.ORDER_TYPE_BUY else entry_price + SL_DOLLARS

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": SYMBOL,
        "volume": LOT_SIZE,
        "type": direction,
        "price": entry_price,
        "sl": sl,
        "tp": tp,
        "deviation": 20,
        "magic": 123456,
        "comment": "WMA5 Crossover Strategy",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Order failed: {result.retcode}")
    else:
        print(f"‚úÖ Order placed: {'BUY' if direction == 0 else 'SELL'} | Ticket: {result.order}")
    return result

# === FUNCTION: Close Opposite Trade ===
def close_position(position):
    direction = mt5.ORDER_TYPE_SELL if position.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
    price = mt5.symbol_info_tick(SYMBOL).bid if direction == mt5.ORDER_TYPE_BUY else mt5.symbol_info_tick(SYMBOL).ask

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": SYMBOL,
        "volume": position.volume,
        "type": direction,
        "position": position.ticket,
        "price": price,
        "deviation": 20,
        "magic": 123456,
        "comment": "Close on opposite crossover",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Close failed: {result.retcode}")
    else:
        print(f"üîÅ Position closed: {position.ticket}")
    return result

# === MAIN LOOP ===
last_candle_time = None

while True:
    df = get_candles()
    ask, bid, current_price = get_prices()

    if df.shape[0] < WMA_PERIOD + 1 or df['wma'].isnull().any():
        time.sleep(CHECK_INTERVAL)
        continue

    curr = df.iloc[-1]
    prev = df.iloc[-2]

    # Only act once per new candle
    if last_candle_time == curr['time']:
        time.sleep(CHECK_INTERVAL)
        continue

    # Fetch open position
    positions = mt5.positions_get(symbol=SYMBOL)
    position = positions[0] if positions else None

    # Entry Conditions
    buy_signal = (current_price > curr['wma']) and (ask > curr['wma']) and (prev['close'] < prev['wma'])
    sell_signal = (current_price < curr['wma']) and (bid < curr['wma']) and (prev['close'] > prev['wma'])

    if position:
        # If opposite signal, close and reverse
        if position.type == mt5.ORDER_TYPE_BUY and sell_signal:
            close_position(position)
            time.sleep(1)
            place_order(mt5.ORDER_TYPE_SELL)
            last_candle_time = curr['time']

        elif position.type == mt5.ORDER_TYPE_SELL and buy_signal:
            close_position(position)
            time.sleep(1)
            place_order(mt5.ORDER_TYPE_BUY)
            last_candle_time = curr['time']

    else:
        # No position, place fresh order
        if buy_signal:
            place_order(mt5.ORDER_TYPE_BUY)
            last_candle_time = curr['time']
        elif sell_signal:
            place_order(mt5.ORDER_TYPE_SELL)
            last_candle_time = curr['time']

    time.sleep(CHECK_INTERVAL)
