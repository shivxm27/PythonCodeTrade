import MetaTrader5 as mt5
import time
from datetime import datetime
import pandas as pd
import numpy as np

# === CONFIG ===
SYMBOL = "BTCUSDm"
TIMEFRAME = mt5.TIMEFRAME_M15
LOT_SIZE = 0.20
TP_DOLLARS = 100
SL_DOLLARS = 30
WMA_PERIOD = 5
CHECK_INTERVAL = 5  # seconds

# === INITIALIZE MT5 ===
if not mt5.initialize():
    print("‚ùå MT5 initialization failed:", mt5.last_error())
    quit()

print("‚úÖ MT5 Initialized. Starting strategy...")

# === FUNCTION: Get Historical Candles + WMA ===
def get_candles():
    rates = mt5.copy_rates_from_pos(SYMBOL, TIMEFRAME, 0, WMA_PERIOD + 2)
    df = pd.DataFrame(rates)
    df['time'] = pd.to_datetime(df['time'], unit='s')
    weights = np.arange(1, WMA_PERIOD + 1)
    df['wma'] = df['close'].rolling(WMA_PERIOD).apply(
        lambda x: np.dot(x, weights) / weights.sum(), raw=True)
    return df

# === FUNCTION: Get Latest Tick Prices ===
def get_prices():
    tick = mt5.symbol_info_tick(SYMBOL)
    ask = tick.ask
    bid = tick.bid
    price = (ask + bid) / 2
    return ask, bid, price

# === FUNCTION: Place Buy/Sell Order ===
def place_order(direction):
    ask, bid, _ = get_prices()
    entry_price = ask if direction == mt5.ORDER_TYPE_BUY else bid
    tp = entry_price + TP_DOLLARS if direction == mt5.ORDER_TYPE_BUY else entry_price - TP_DOLLARS
    sl = entry_price - SL_DOLLARS if direction == mt5.ORDER_TYPE_BUY else entry_price + SL_DOLLARS

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": SYMBOL,
        "volume": LOT_SIZE,
        "type": direction,
        "price": entry_price,
        "sl": sl,
        "tp": tp,
        "deviation": 20,
        "magic": 123456,
        "comment": "WMA5 Crossover Strategy",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    print("üöÄ Sending order...")
    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Order failed: {result.retcode}")
    else:
        print(f"‚úÖ Order placed: {'BUY' if direction == 0 else 'SELL'} | Ticket: {result.order}")
    return result

# === FUNCTION: Close Opposite Trade ===
def close_position(position):
    direction = mt5.ORDER_TYPE_SELL if position.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
    price = mt5.symbol_info_tick(SYMBOL).bid if direction == mt5.ORDER_TYPE_BUY else mt5.symbol_info_tick(SYMBOL).ask

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": SYMBOL,
        "volume": position.volume,
        "type": direction,
        "position": position.ticket,
        "price": price,
        "deviation": 20,
        "magic": 123456,
        "comment": "Close on opposite crossover",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }

    print("üîÅ Closing position...")
    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Close failed: {result.retcode}")
    else:
        print(f"üîÅ Position closed: {position.ticket}")
    return result

# === MAIN LOOP ===
last_candle_time = None
print("üì° Monitoring BTCUSDm every", CHECK_INTERVAL, "seconds...")

while True:
    df = get_candles()
    ask, bid, current_price = get_prices()

    if df.shape[0] < WMA_PERIOD + 1 or df['wma'].isnull().any():
        print("‚è≥ Not enough data or WMA not ready. Waiting...")
        time.sleep(CHECK_INTERVAL)
        continue

    curr = df.iloc[-1]
    prev = df.iloc[-2]

    if last_candle_time == curr['time']:
        print("‚è∏ Same candle. Waiting for new one...")
        time.sleep(CHECK_INTERVAL)
        continue

    print(f"\nüïí New candle detected: {curr['time']}")
    print(f"üìà WMA: {curr['wma']:.2f}, Close: {curr['close']:.2f}, Ask: {ask:.2f}, Bid: {bid:.2f}")

    positions = mt5.positions_get(symbol=SYMBOL)
    position = positions[0] if positions else None

    # === ENTRY CONDITIONS ===
    buy_signal = (current_price > curr['wma']) and (ask > curr['wma']) and (prev['close'] < prev['wma'])
    sell_signal = (current_price < curr['wma']) and (bid < curr['wma']) and (prev['close'] > prev['wma'])
    print(f"üîç Buy Signal: {buy_signal}, Sell Signal: {sell_signal}")

    if position:
        if position.type == mt5.ORDER_TYPE_BUY and sell_signal:
            close_position(position)
            time.sleep(1)
            place_order(mt5.ORDER_TYPE_SELL)
            last_candle_time = curr['time']

        elif position.type == mt5.ORDER_TYPE_SELL and buy_signal:
            close_position(position)
            time.sleep(1)
            place_order(mt5.ORDER_TYPE_BUY)
            last_candle_time = curr['time']
    else:
        if buy_signal:
            place_order(mt5.ORDER_TYPE_BUY)
            last_candle_time = curr['time']
        elif sell_signal:
            place_order(mt5.ORDER_TYPE_SELL)
            last_candle_time = curr['time']

    time.sleep(CHECK_INTERVAL)
